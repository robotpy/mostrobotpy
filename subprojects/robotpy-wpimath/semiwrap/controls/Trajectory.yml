defaults:
  subpackage: trajectory

extra_includes:
- rpy/geometryToString.h
- nanobind/stl/string.h

functions:
  to_json:
    ignore: true
  from_json:
    ignore: true
classes:
  frc::Trajectory:
    force_type_casters:
    - units::curvature_t
    methods:
      Trajectory:
        overloads:
          '':
          const std::vector<State>&:
      TotalTime:
      States:
      Sample:
      TransformBy:
      RelativeTo:
      InitialPose:
      operator+:
      operator==:
  frc::Trajectory::State:
    force_no_default_constructor: true
    attributes:
      t:
      velocity:
      acceleration:
      pose:
      curvature:
    methods:
      operator==:
      Interpolate:

inline_code: |
  cls_State
    .def(
      nb::init<
        units::second_t,
        units::meters_per_second_t,
        units::meters_per_second_squared_t,
        Pose2d,
        units::curvature_t
      >(),
      nb::arg("t") = 0_s,
      nb::arg("velocity") = 0_mps,
      nb::arg("acceleration") = 0_mps_sq,
      nb::arg("pose") = Pose2d(),
      nb::arg("curvature") = 0.0
    )
    .def_prop_ro("velocity_fps", [](frc::Trajectory::State * self) -> units::feet_per_second_t {
      return self->velocity;
    })
    .def_prop_ro("acceleration_fps", [](frc::Trajectory::State * self) -> units::feet_per_second_squared_t {
      return self->acceleration;
    })
    .def("__repr__", [](frc::Trajectory::State *self) {
      return "Trajectory.State("
        "t=" + std::to_string(self->t()) + ", "
        "velocity=" + std::to_string(self->velocity()) + ", "
        "acceleration=" + std::to_string(self->acceleration()) + ", "
        "pose=" + rpy::toString(self->pose) + ", "
        "curvature=" + std::to_string(self->curvature()) + ")";
    })
    .def_rw("curvature", &frc::Trajectory::State::curvature);
