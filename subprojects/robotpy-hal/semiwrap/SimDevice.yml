defaults:
  ignore: true
  report_ignored_missing: false

extra_includes:
- hal/simulation/SimDeviceData.h

strip_prefixes:
- HAL_

enums:
  HAL_SimValueDirection:
classes:
  hal::SimValue:
    doc: |
      Readonly wrapper around a HAL simulator value.

      It is not useful to construct these directly -- they are returned from
      :meth:`.SimDeviceSim.getValue` or :meth:`.SimDevice.createValue`.
    methods:
      SimValue:
        overloads:
          '':
            ignore: true
          HAL_SimValueHandle:
            param_override:
              val:
                name: handle
      GetValue:
        ignore: true
      SetValue:
        ignore: true
  hal::SimInt:
    doc: |
      Wrapper around a HAL simulator int value handle.

      It is not useful to construct these directly, they are returned
      from various functions.
    force_no_trampoline: true
    methods:
      SimInt:
        overloads:
          '':
            ignore: true
          HAL_SimValueHandle:
            param_override:
              val:
                name: handle
      Get:
      Set:
      Reset:
  hal::SimLong:
    doc: |
      Wrapper around a HAL simulator long value handle.

      It is not useful to construct these directly, they are returned
      from various functions.
    force_no_trampoline: true
    methods:
      SimLong:
        overloads:
          '':
            ignore: true
          HAL_SimValueHandle:
            param_override:
              val:
                name: handle
      Get:
      Set:
      Reset:
  hal::SimDouble:
    doc: |
      Wrapper around a HAL simulator double value.

      It is not useful to construct these directly -- they are returned from
      :meth:`.SimDeviceSim.getDouble` or :meth:`.SimDevice.createDouble`.
    force_no_trampoline: true
    methods:
      SimDouble:
        overloads:
          '':
            ignore: true
          HAL_SimValueHandle:
            param_override:
              val:
                name: handle
      Get:
      Set:
      Reset:
  hal::SimEnum:
    doc: |
      Wrapper around a HAL simulator enum value.

      It is not useful to construct these directly -- they are returned from
      :meth:`.SimDeviceSim.getEnum` or :meth:`.SimDevice.createEnum`.
    force_no_trampoline: true
    methods:
      SimEnum:
        overloads:
          '':
            ignore: true
          HAL_SimValueHandle:
            param_override:
              val:
                name: handle
      Get:
      Set:
  hal::SimBoolean:
    doc: |
      Wrapper around a HAL simulator boolean value.

      It is not useful to construct these directly -- they are returned from
      :meth:`.SimDeviceSim.getBoolean` or :meth:`.SimDevice.createBoolean`.
    force_no_trampoline: true
    methods:
      SimBoolean:
        overloads:
          '':
            ignore: true
          HAL_SimValueHandle:
            param_override:
              val:
                name: handle
      Get:
      Set:
  hal::SimDevice:
    doc: |
      Wrapper around a HAL simulation 'device'

      This creates a simulated 'device' object that can be interacted with
      from user SimDeviceSim objects or via the Simulation GUI.

      .. note:: To interact with an existing device use
                :class:`hal.simulation.SimDeviceSim` instead.
    force_type_casters:
    - wpi::SmallVector
    enums:
      Direction:
    methods:
      SimDevice:
        overloads:
          '':
            ignore: true
          const char*:
          const char*, int:
          const char*, int, int:
      GetName:
      CreateValue:
        ignore: true
      CreateDouble:
      CreateEnum:
        overloads:
          const char*, int32_t, std::initializer_list<const char *>, int32_t:
            ignore: true
          const char*, int32_t, std::span<const char * const>, int32_t:
            cpp_code: |
              [](SimDevice &self, const char * name, int32_t direction, const wpi::SmallVector<std::string, 8> &options, int32_t initialValue) {
                wpi::SmallVector<const char *, 8> coptions;
                coptions.reserve(options.size());
                for (auto &s: options) {
                  coptions.push_back(s.c_str());
                }
                return self.CreateEnum(name, direction, coptions, initialValue);
              }

      CreateEnumDouble:
        overloads:
          const char*, int32_t, std::initializer_list<const char *>, std::initializer_list<double>, int32_t:
            ignore: true
          const char*, int32_t, std::span<const char * const>, std::span<const double>, int32_t:
            cpp_code: |
              [](SimDevice &self, const char * name, int32_t direction, const wpi::SmallVector<std::string, 8> &options, const wpi::SmallVector<double, 8> &optionValues, int32_t initialValue) {
                wpi::SmallVector<const char *, 8> coptions;
                coptions.reserve(options.size());
                for (auto &s: options) {
                  coptions.push_back(s.c_str());
                }
                return self.CreateEnumDouble(name, direction, coptions, optionValues, initialValue);
              }

      CreateBoolean:
      CreateInt:
      CreateLong:

inline_code: |2

  cls_SimValue
    .def_prop_ro("value", [](const hal::SimValue &self) -> nb::object {
        HAL_Value value;
        {
          nb::gil_scoped_release release;
          value = self.GetValue();
        }
        switch (value.type) {
        case HAL_BOOLEAN:
          return nb::bool_(value.data.v_boolean);
        case HAL_DOUBLE:
          return nb::float_(value.data.v_double);
        case HAL_ENUM:
          return nb::int_(value.data.v_enum);
        case HAL_INT:
          return nb::int_(value.data.v_int);
        case HAL_LONG:
          return nb::int_(value.data.v_long);
        default: 
          return nb::none();
        }
    })
    .def_prop_ro("type", [](const hal::SimValue &self) -> HAL_Type {
      nb::gil_scoped_release release;
      return self.GetValue().type;
    })
    .def("__bool__", [](const hal::SimValue &self) -> bool {
      return (bool)self;
    })
    .def("__repr__", [](const hal::SimValue &self) -> nb::str {
        if (!self) {
          return nb::str("<SimValue (invalid)>");
        }
        HAL_Value value;
        {
          nb::gil_scoped_release release;
          value = self.GetValue();
        }
        switch (value.type) {
        case HAL_BOOLEAN:
          if (value.data.v_boolean) {
            return nb::str("<SimValue (bool) True>");
          } else {
            return nb::str("<SimValue (bool) False>");
          }
        case HAL_DOUBLE:
          return nb::str("<SimValue (double) {}>").format(value.data.v_double);
        case HAL_ENUM:
          return nb::str("<SimValue (enum) {}>").format(value.data.v_enum);
        case HAL_INT:
          return nb::str("<SimValue (int) {}>").format(value.data.v_int);
        case HAL_LONG:
          return nb::str("<SimValue (long) {}>").format(value.data.v_long);
        default:
          return nb::str("<SimValue (unknown)>");
        }
    });

  cls_SimBoolean
    .def_prop_rw("value", &SimBoolean::Get, &SimBoolean::Set, release_gil())
    .def("__repr__", [](const SimBoolean &self) -> nb::str {
      if (self) {
        bool value;
        {
          nb::gil_scoped_release release;
          value = self.Get();
        }
        return nb::str("<SimBoolean value={}>").format(value ? "True" : "False");
      } else {
        return nb::str("<SimBoolean (invalid)>");
      }
    });

  cls_SimDevice
    .def("__bool__", [](const hal::SimDevice &self) -> bool {
      return (bool)self;
    })
    .def_prop_ro("name", [](const hal::SimDevice &self) -> nb::str {
      #ifdef __FRC_ROBORIO__
        return nb::str("<invalid>");
      #else
        if (!self) {
          return nb::str("<invalid>");
        } else {
          const char *name;
          {
            nb::gil_scoped_release release;
            name = HALSIM_GetSimDeviceName(self);
          }
          return nb::str(name);
        }
      #endif
    })
    .def("__repr__", [](const hal::SimDevice &self) -> nb::str {
      #ifdef __FRC_ROBORIO__
        return nb::str("<SimDevice (invalid)>");
      #else
        if (!self) {
          return nb::str("<SimDevice (invalid)>");
        }
        const char *name;
        {
          nb::gil_scoped_release release;
          name = HALSIM_GetSimDeviceName(self);
        }
        return nb::str("SimDevice(name={!r})").format(nb::str(name));
      #endif
    });

  cls_SimDouble
    .def_prop_rw("value", &SimDouble::Get, &SimDouble::Set, release_gil())
    .def("__repr__", [](const SimDouble &self) -> nb::str {
      if (self) {
        double value;
        {
          nb::gil_scoped_release release;
          value = self.Get();
        }
        return nb::str("<SimDouble value={}>").format(value);
      } else {
        return nb::str("<SimDouble (invalid)>");
      }
    });

  cls_SimEnum
    .def_prop_rw("value", &SimEnum::Get, &SimEnum::Set)
    .def("__repr__", [](const SimEnum &self) -> nb::str {
      #ifdef __FRC_ROBORIO__
        return nb::str("<SimEnum (invalid)>");
      #else
        if (self) {
          int32_t value;
          int32_t numOptions;
          int32_t numdOptions;
          const char ** options;
          const double * doptions;
          const char * option = "<unknown>";
          std::string doption;
          {
            nb::gil_scoped_release release;
            value = self.Get();
            options = HALSIM_GetSimValueEnumOptions(self, &numOptions);
            doptions = HALSIM_GetSimValueEnumDoubleValues(self, &numdOptions);
          }

          if (options && value >= 0 && value < numOptions) {
            option = options[value];
          }

          if (doptions && value >= 0 && value < numdOptions) {
            doption = " dvalue=" + std::to_string(doptions[value]);
          }

          return nb::str("<SimEnum name={} value={}{}>").format(option, value, doption);
        } else {
          return nb::str("<SimEnum (invalid)>");
        }
      #endif
    });

  cls_SimInt
    .def_prop_rw("value", &SimInt::Get, &SimInt::Set)
    .def("__repr__", [](const SimInt &self) -> nb::str {
      if (self) {
        int32_t value;
        {
          nb::gil_scoped_release release;
          value = self.Get();
        }
        return nb::str("<SimInt value={}>").format(value);
      } else {
        return nb::str("<SimInt (invalid)>");
      }
    });

  cls_SimLong
    .def_prop_rw("value", &SimLong::Get, &SimLong::Set)
    .def("__repr__", [](const SimLong &self) -> nb::str {
      if (self) {
        int64_t value;
        {
          nb::gil_scoped_release release;
          value = self.Get();
        }
        return nb::str("<SimLong value={}>").format(value);
      } else {
        return nb::str("<SimLong (invalid)>");
      }
    });
